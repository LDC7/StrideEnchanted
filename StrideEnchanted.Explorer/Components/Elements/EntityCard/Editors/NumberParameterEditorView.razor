@using System
@using Microsoft.AspNetCore.Components.Web
@using MudBlazor
@using StrideEnchanted.Explorer.Interfaces
@using System.ComponentModel
@using System.Numerics

@typeparam T where T : struct, INumber<T>
@implements IDisposable

<MudStack Row="@true">

  @if (this.isNullable)
  {
    <MudSwitch T="bool"
               Class="my-1"
               Color="@MudBlazor.Color.Primary"
               Value="@this.hasValue"
               ValueChanged="@this.HandleHasValueChanged" />
  }

  <MudNumericField T="@(T ?)"
                   @ref="@this.editorRef"
                   Label="@this.Parameter.Name"
                   Value="@(this.hasValue ? this.internalValue : default)"
                   Class="my-1"
                   HideSpinButtons="@true"
                   Disabled="@(!this.hasValue)"
                   ValueChanged="@this.HandleValueChanged"
                   OnKeyDown="@this.HandleKeyDown"
                   OnBlur="@this.HandleBlur" />

</MudStack>

@code {
  private MudNumericField<T?> editorRef = default!;
  private T? internalValue = default;
  private bool isEditing = false;
  private bool hasValue = true;
  private bool isNullable = false;

  [Parameter]
  [EditorRequired]
  public required ITrackedEntityComponentParameter Parameter { get; set; } = default!;

  protected override Task OnInitializedAsync()
  {
    var parameterType = Nullable.GetUnderlyingType(this.Parameter.ParameterType);
    this.isNullable = parameterType is not null;
    parameterType ??= this.Parameter.ParameterType;
    this.hasValue = !this.isNullable || this.Parameter.Value is not null;
    this.internalValue = this.hasValue ? (T?)this.Parameter.Value : null;

    this.Parameter.PropertyChanged += this.OnPropertyChanged;
    return base.OnInitializedAsync();
  }

  private void HandleValueChanged(T? newValue)
  {
    if (!object.Equals(this.internalValue, newValue))
    {
      this.isEditing = true;
      this.internalValue = newValue;

      if (this.isNullable)
        this.hasValue = newValue is not null;
    }
  }

  private void HandleHasValueChanged(bool newValue)
  {
    if (!this.isNullable || this.hasValue == newValue)
      return;

    this.hasValue = newValue;
    this.isEditing = false;

    if (!this.hasValue)
      this.internalValue = null;

    this.ApplyInternalValue();
  }

  private async Task HandleKeyDown(KeyboardEventArgs args)
  {
    if (args.Key == "Enter")
      await this.BlurAsync();
  }

  private Task HandleBlur(FocusEventArgs args)
  {
    this.ApplyInternalValue();
    return Task.CompletedTask;
  }

  private void ApplyInternalValue()
  {
    this.isEditing = false;

    if (!this.hasValue)
    {
      this.Parameter.SetValue(null);
      return;
    }

    this.Parameter.SetValue(this.isNullable ? this.internalValue : this.internalValue!.Value);
  }

  private async Task BlurAsync()
  {
    await this.editorRef.BlurAsync();
  }

  private void OnPropertyChanged(object? sender, PropertyChangedEventArgs _)
  {
    if (this.isEditing)
      return;

    this.hasValue = !this.isNullable || this.Parameter.Value is not null;
    this.internalValue = this.hasValue ? (T?)this.Parameter.Value : null;

    this.InvokeAsync(this.StateHasChanged);
  }

  public void Dispose()
  {
    this.Parameter.PropertyChanged -= this.OnPropertyChanged;
  }
}
